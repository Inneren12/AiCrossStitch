package com.appforcross.quant

import android.graphics.Bitmap
import android.graphics.Color
import com.appforcross.editor.analysis.Masks
import kotlin.math.*
import java.util.PriorityQueue

/** Настройки роста палитры и квантизации. */
data class QuantOptions(
    val kStart: Int = 16,
    val kMax: Int = 32,
    val deltaEMin: Double = 3.0,               // минимальная дистанция между цветами (OKLab ΔE)
    val roiWeights: ROIWeights = ROIWeights(), // веса по регионам
    val earlyStopGain: Double = 0.010,         // минимальный прирост score на шаг
    val maxIter: Int = 64
)

data class ROIWeights(
    val wEdge: Double = 1.3,
    val wSkin: Double = 1.6,
    val wSky: Double = 1.2,
    val wHiTex: Double = 1.2,
    val wFlat: Double = 0.9
)

data class QuantResult(
    val palette: IntArray,         // ARGB sRGB 8-bit
    val index: IntArray,           // индексы palette для каждого пикселя (size = w*h)
    val metrics: QuantMetrics
)

data class QuantMetrics(
    val k: Int,
    val deMin: Double,
    val deMed: Double,
    val avgErr: Double,
    val top8Coverage: Double
)

/** Рост палитры Greedy+ и квантизация (OKLab). */
object PaletteQuant {

    /** Главная функция: строит палитру и квантует bitmap (в sRGB). */
    fun run(
        src: Bitmap,              // допускаем ARGB_8888 или F16 — тут работаем в sRGB
        masks: Masks,             // маски (будут ресемплены выше по потоку)
        opts: QuantOptions
    ): QuantResult {
        val w = src.width; val h = src.height; val n = w*h
        val px = IntArray(n); src.getPixels(px, 0, w, 0, 0, w, h)

        // 1) Данные в OKLab и карта важности (ROI weights)
        val lab = FloatArray(n * 3)
        val imp = DoubleArray(n) { 1.0 }
        fillLabAndImportance(px, w, h, lab, imp, masks, opts.roiWeights)

        // 2) Инициализация палитры (kStart): берём kStart медоидов по k-means++‑подобной схеме
        var centers = initCentersKpp(lab, imp, opts.kStart)

        // 3) Greedy рост: на каждом шаге — делим «худший» кластер (split-largest)
        var assign = IntArray(n) { 0 }
        var err = assignAndError(lab, imp, centers, assign)
        var scorePrev = -1.0

        var k = centers.size/3
        val improvWindow = ArrayDeque<Double>()
        var iter = 0
        while (k < opts.kMax && iter < opts.maxIter) {
            iter++
            val worst = worstCluster(lab, imp, centers, assign)
            if (worst.count == 0) break
            // новый центр = медиоид кластера (точка с мин. суммой расстояний)
            val newC = medoidOfCluster(worst, lab)
            centers = addCenter(centers, newC)      // ⬅️ реально увеличиваем массив центров
            k = centers.size / 3
            // Быстрая локальная 2-opt: подвинем новый центр и ближайшего соседа
            val idB = (k - 1).coerceAtLeast(0)      // новый центр — последний
            refineTwoCenters(lab, imp, centers, worst.id.coerceIn(0, k - 1), idB)
            // Обновить присвоение
            err = assignAndError(lab, imp, centers, assign)
            // palette-spread: выдержать ΔE_min
            enforceDeltaEMin(centers, opts.deltaEMin)

            val score = -err.total      // чем меньше ошибка — тем лучше score
            val gain = if (scorePrev < 0) 1.0 else (score - scorePrev)
                improvWindow.addLast(gain)
            if (improvWindow.size > 5) improvWindow.removeFirst()
            val avgGain = improvWindow.average()
            scorePrev = score
            // ранняя остановка
            if (avgGain < opts.earlyStopGain) break
        }

        // 4) Финальное присвоение и пересчёт метрик
        err = assignAndError(lab, imp, centers, assign)
        val (deMin, deMed) = paletteSeparation(centers)
        val top8 = top8Coverage(px)
        val palArgb = centersToArgb(centers)
        return QuantResult(
            palette = palArgb,
            index = assign,
            metrics = QuantMetrics(k = palArgb.size, deMin = deMin, deMed = deMed, avgErr = err.total / imp.sum(), top8Coverage = top8)
        )
    }

    // ---------- Core helpers ----------
    private data class AssignErr(val total: Double)
    private fun assignAndError(lab: FloatArray, imp: DoubleArray, centers: FloatArray, assignOut: IntArray): AssignErr {
        var tot = 0.0
        val k = centers.size/3
        for (i in 0 until assignOut.size) {
            val L = lab[i*3  ]; val A = lab[i*3+1]; val B = lab[i*3+2]
            var best = 0; var bestD = Double.POSITIVE_INFINITY
            for (c in 0 until k) {
                val d = de2(L,A,B, centers[c*3], centers[c*3+1], centers[c*3+2])
                if (d < bestD) { bestD = d; best = c }
            }
            assignOut[i] = best
            tot += bestD * imp[i]
        }
        return AssignErr(tot)
    }

    private data class ClusterAcc(
        val id: Int,
        var sumL: Double = 0.0, var sumA: Double = 0.0, var sumB: Double = 0.0,
        var count: Int = 0,
        var weightedErr: Double = 0.0
    )
    private fun worstCluster(lab: FloatArray, imp: DoubleArray, centers: FloatArray, assign: IntArray): ClusterAcc {
        val k = centers.size/3
        val acc = Array(k) { ClusterAcc(it) }
        for (i in assign.indices) {
            val c = assign[i]
            val L=lab[i*3]; val A=lab[i*3+1]; val B=lab[i*3+2]
            val d = de2(L,A,B, centers[c*3], centers[c*3+1], centers[c*3+2])
            val w = imp[i]
            val a = acc[c]
            a.sumL += L*w; a.sumA += A*w; a.sumB += B*w; a.count++
            a.weightedErr += d*w
        }
        return acc.maxBy { it.weightedErr / max(1, it.count) }
    }

    private fun medoidOfCluster(cl: ClusterAcc, lab: FloatArray): FloatArray {
        if (cl.count == 0) return floatArrayOf(0.5f, 0.0f, 0.0f)
        // упрощенно: возьмём «центроид» как старт и вернём его как новый центр
        val L = (cl.sumL / max(1, cl.count)).toFloat()
        val A = (cl.sumA / max(1, cl.count)).toFloat()
        val B = (cl.sumB / max(1, cl.count)).toFloat()
        return floatArrayOf(L,A,B)
    }

    private fun addCenter(centers: FloatArray, c: FloatArray): FloatArray {
        val out = FloatArray(centers.size + 3)
        System.arraycopy(centers, 0, out, 0, centers.size)
        out[out.size-3] = c[0]; out[out.size-2] = c[1]; out[out.size-1] = c[2]
        return out
    }

    private fun refineTwoCenters(lab: FloatArray, imp: DoubleArray, centers: FloatArray, idA: Int, idB: Int) {
        // одна итерация: сместим каждый центр к своему взвешенному среднему
        val k = centers.size/3
        val sumL = DoubleArray(k); val sumA = DoubleArray(k); val sumB = DoubleArray(k); val sumW = DoubleArray(k)
        for (i in 0 until lab.size/3) {
            // назначение — ближайший центр (локально, между двумя)
            val L=lab[i*3]; val A=lab[i*3+1]; val B=lab[i*3+2]
            val dA = de2(L,A,B, centers[idA*3], centers[idA*3+1], centers[idA*3+2])
            val dB = de2(L,A,B, centers[idB*3], centers[idB*3+1], centers[idB*3+2])
            val pick = if (dA <= dB) idA else idB
            val w = imp[i]
            sumL[pick]+=L*w; sumA[pick]+=A*w; sumB[pick]+=B*w; sumW[pick]+=w
        }
        if (sumW[idA]>0.0) {
            centers[idA*3] = (sumL[idA]/sumW[idA]).toFloat()
            centers[idA*3+1] = (sumA[idA]/sumW[idA]).toFloat()
            centers[idA*3+2] = (sumB[idA]/sumW[idA]).toFloat()
        }
        if (sumW[idB]>0.0) {
            centers[idB*3] = (sumL[idB]/sumW[idB]).toFloat()
            centers[idB*3+1] = (sumA[idB]/sumW[idB]).toFloat()
            centers[idB*3+2] = (sumB[idB]/sumW[idB]).toFloat()
        }
    }

    private fun enforceDeltaEMin(centers: FloatArray, dMin: Double) {
        val k = centers.size/3
        var changed = true; var guard = 0
        while (changed && guard < 5) {
            changed = false; guard++
            for (i in 0 until k) for (j in i+1 until k) {
                val d = sqrt(de2(centers[i*3], centers[i*3+1], centers[i*3+2],
                    centers[j*3], centers[j*3+1], centers[j*3+2]))
                if (d < dMin && d > 1e-6) {
                    // слегка раздвинем по направлению друг от друга
                    val t = ((dMin - d) / dMin).coerceAtMost(0.5)
                    val dxL = centers[i*3]   - centers[j*3]
                    val dxA = centers[i*3+1] - centers[j*3+1]
                    val dxB = centers[i*3+2] - centers[j*3+2]
                    centers[i*3]   = (centers[i*3]   + dxL*(t*0.5)).toFloat()
                    centers[i*3+1] = (centers[i*3+1] + dxA*(t*0.5)).toFloat()
                    centers[i*3+2] = (centers[i*3+2] + dxB*(t*0.5)).toFloat()
                    centers[j*3]   = (centers[j*3]   - dxL*(t*0.5)).toFloat()
                    centers[j*3+1] = (centers[j*3+1] - dxA*(t*0.5)).toFloat()
                    centers[j*3+2] = (centers[j*3+2] - dxB*(t*0.5)).toFloat()
                    changed = true
                }
            }
        }
    }

    private fun centersToArgb(centers: FloatArray): IntArray {
        val k = centers.size/3
        val out = IntArray(k)
        for (i in 0 until k) {
            val rgb = okLabToSRgb(centers[i*3], centers[i*3+1], centers[i*3+2])
            out[i] = Color.rgb(
                (rgb[0].coerceIn(0f,1f)*255f + 0.5f).toInt(),
                (rgb[1].coerceIn(0f,1f)*255f + 0.5f).toInt(),
                (rgb[2].coerceIn(0f,1f)*255f + 0.5f).toInt()
            )
        }
        return out
    }

    private fun paletteSeparation(centers: FloatArray): Pair<Double, Double> {
        val k = centers.size/3
        if (k<=1) return 0.0 to 0.0
        val ds = ArrayList<Double>()
        for (i in 0 until k) for (j in i+1 until k) {
            val d = sqrt(de2(centers[i*3], centers[i*3+1], centers[i*3+2],
                centers[j*3], centers[j*3+1], centers[j*3+2]))
            ds.add(d)
        }
        ds.sort()
        return ds.first() to ds[ds.size/2]
    }

    private fun top8Coverage(px: IntArray): Double {
        val hist = HashMap<Int, Int>(1024)
        for (p in px) hist[p] = (hist[p] ?: 0) + 1
        val counts = hist.values.sortedDescending()
        val top = counts.take(8).sum()
        return top.toDouble() / px.size
    }

    // ---------- Conversions & distances ----------
    private fun fillLabAndImportance(
        px: IntArray, w:Int, h:Int, lab: FloatArray, imp: DoubleArray, masks: Masks, weights: ROIWeights
    ) {
        val edge = alphaToBool(masks.edge)
        val flat = alphaToBool(masks.flat)
        val skin = alphaToBool(masks.skin)
        val sky  = alphaToBool(masks.sky)
        val hitf = alphaToBool(masks.hiTexFine)
        val hitc = alphaToBool(masks.hiTexCoarse)
        for (i in px.indices) {
            val c = Color.valueOf(px[i])
            val LRGB = floatArrayOf(srgbToLinear(c.red()), srgbToLinear(c.green()), srgbToLinear(c.blue()))
            val ok = rgbLinearToOKLab(LRGB[0], LRGB[1], LRGB[2])
            lab[i*3] = ok[0]; lab[i*3+1] = ok[1]; lab[i*3+2] = ok[2]
            var wgt = 1.0
            if (edge[i]) wgt *= weights.wEdge
            if (skin[i]) wgt *= weights.wSkin
            if (sky[i])  wgt *= weights.wSky
            if (hitf[i] || hitc[i]) wgt *= weights.wHiTex
            if (flat[i]) wgt *= weights.wFlat
            imp[i] = wgt
        }
    }

    private fun alphaToBool(bmp: Bitmap): BooleanArray {
        val w=bmp.width; val h=bmp.height
        val out = BooleanArray(w*h)
        val row = IntArray(w)
        var i=0
        for (y in 0 until h) {
            bmp.getPixels(row,0,w,0,y,w,1)
            for (x in 0 until w) {
                out[i++] = (row[x] ushr 24) != 0
            }
        }
        return out
    }

    // OKLab helpers (как в других модулях)
    private fun cbrtF(x: Float) = if (x <= 0f) 0f else x.pow(1f/3f)
    private fun rgbLinearToOKLab(r: Float, g: Float, b: Float): FloatArray {
        val l = 0.4122214708f * r + 0.5363325363f * g + 0.0514459929f * b
        val m = 0.2119034982f * r + 0.6806995451f * g + 0.1073969566f * b
        val s = 0.0883024619f * r + 0.2817188376f * g + 0.6299787005f * b
        val l_ = cbrtF(l); val m_ = cbrtF(m); val s_ = cbrtF(s)
        val L = 0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_
        val A = 1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_
        val B = 0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
        return floatArrayOf(L, A, B)
    }
    private fun okLabToSRgb(L: Float, A: Float, B: Float): FloatArray {
        // обратная конверсия (по стандартным формулам OKLab)
        val l_ = (L + 0.3963377774f * A + 0.2158037573f * B)
        val m_ = (L - 0.1055613458f * A - 0.0638541728f * B)
        val s_ = (L - 0.0894841775f * A - 1.2914855480f * B)
        val l = l_*l_*l_
        val m = m_*m_*m_
        val s = s_*s_*s_
        val r = +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s
        val g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s
        val b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
        return floatArrayOf(linearToSrgb(r), linearToSrgb(g), linearToSrgb(b))
    }
    private fun de2(L1:Float,A1:Float,B1:Float, L2:Float,A2:Float,B2:Float): Double {
        val dL=(L1-L2).toDouble(); val dA=(A1-A2).toDouble(); val dB=(B1-B2).toDouble()
        return dL*dL + dA*dA + dB*dB
    }
    private fun srgbToLinear(c: Float) = if (c <= 0.04045f) c / 12.92f else ((c + 0.055f) / 1.055f).pow(2.4f)
    private fun linearToSrgb(c: Float): Float {
        val x = c.coerceIn(0f,1f)
        return if (x <= 0.0031308f) 12.92f*x else 1.055f * x.pow(1/2.4f) - 0.055f
    }

    // ---------- K-means++ style init ----------
    private fun initCentersKpp(lab: FloatArray, imp: DoubleArray, k: Int): FloatArray {
        val n = lab.size/3
        val centers = ArrayList<Float>(k*3)
        // 1) первый центр = медианная точка по L
        val idx0 = n/2
        centers.add(lab[idx0*3]); centers.add(lab[idx0*3+1]); centers.add(lab[idx0*3+2])
        val dist = DoubleArray(n){ Double.POSITIVE_INFINITY }
        // 2) последующие — с вероятностью ∝ D^2 * imp
        for (c in 1 until k) {
            for (i in 0 until n) {
                val L=lab[i*3]; val A=lab[i*3+1]; val B=lab[i*3+2]
                var best=Double.POSITIVE_INFINITY
                for (j in 0 until centers.size/3) {
                    val d = de2(L,A,B, centers[j*3], centers[j*3+1], centers[j*3+2])
                    if (d<best) best=d
                }
                dist[i] = best * imp[i]
            }
            val sum = dist.sum()
            if (sum <= 0.0) break
            var r = Math.random() * sum
            var pick = 0
            while (r > 0 && pick < n-1) { r -= dist[pick]; pick++ }
            centers.add(lab[pick*3]); centers.add(lab[pick*3+1]); centers.add(lab[pick*3+2])
        }
        val out = FloatArray(centers.size)
        for (i in centers.indices) out[i] = centers[i]
        return out
    }
}
